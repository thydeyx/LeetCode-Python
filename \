# -*- coding:utf-8 -*- 

import sys
from Queue import Queue

class Solution(object):

	def comp(self, now_word, next_word):
		n = len(now_word)
		diff = 0
		for i in range(n)
			if now_word[n] != next_word[n]
				diff += 1
			if diff > 1:
				return 0

		return 1


	def findLadders(self, beginWord, endWord, wordlist):
		q = Queue()
		n = len(wordlist)
		fromList = [[sys.maxint, []] for x in range(n + 2)]
		inQ = [0 for x in range(n + 2)]
		inQ[0] = 1
		fromList[0][0] = 0
		q.put((beginWord, fromList[0], 0))
		while q.empty() == False:
			now_word, state, num_word = q.get()
			inQ[num_word] = 0
			if self.comp(now_word, endWord) == 1:
				if state[0] + 1 < fromList[n + 1][0]:
					fromList[n + 1][0] = state[0] + 1
					fromList[n + 1][1] = [num_word]
					if inQ[n + 1] == 0:
						q.put((endWord, fromList[n + 1], n + 1))
						inQ[n + 1] = 1
				elif state[0] + 1 == fromList[n + 1][0]]:
					fromList[n + 1][1].append(num_word)
					if inQ[n + 1] == 0:
						q.put((endWord, fromList[n + 1], n + 1))
						inQ[n + 1] = 1
				break
			for i in range(n):
				if self.comp(now_word, wordlist[i]) == 1:
					if state[0] + 1 < fromList[i + 1][0]:
						fromList[i + 1][0] = state[0] + 1
						fromList[i + 1][1] = [num_word]
						if inQ[i + 1] == 0:
							q.put((wordlist[i], fromList[i + 1]))
							inQ[i + 1] = 1
					elif state[0] + 1 == fromList[i + 1][0]:
						fromList[i + 1][1].append(num_word)
						if inQ[n + 1] == 0:
							q.put((endWord, fromList[n + 1], n + 1))
							inQ[n + 1] = 1

		#if fromList[n + 1][0] != sys.maxint:
			#dfs(fromList)
		print fromList
		return 0


if __name__ == "__main__"
	s = Solution()
	beginWord = "hit"
	endWord = "cog"
	wordList = ["hot","dot","dog","lot","log"]
	s.findLadders(beginWord, endWord, wordlist)
