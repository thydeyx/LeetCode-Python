//class for minKsum
struct Point {
    int x;
    int y;
    int sum;
};
bool operator<(Point a,Point b){
    return a.sum > b.sum;
}
class Solution {
public:
//array A,arrayB, obtain the minest k a[i]+b[j]. that a[0]+b[0] is the minest
    vector<int> minKsum(vector<int> i_A,vector<int> i_B,int k) {
        vector<int> res;
        priority_queue<Point> priorityq;
        if(i_A.size() == 0&&i_B.size() == 0) {
            return res;
        }
        if(i_A.size() == 0) {
            if (i_B.size() > k)
            {
                return res;
            }
            return vector<int>(i_B.begin(),i_B.begin()+k);
        }
        if(i_B.size() == 0) {
            if(i_A.size() > k)
            {
                return res;
            }
            return vector<int>(i_A.begin(),i_A.begin()+k);
        }
        Point first;
        first.x = 0;
        first.y = 0;
        first.sum = i_A[0] + i_B[0];
        priorityq.push(first);
        while (!priorityq.empty()&&res.size() != k)
        {
            Point tmpoutput = priorityq.top();
            priorityq.pop();
            res.push_back(tmpoutput.sum);
            if(tmpoutput.y == 0) {
                if (tmpoutput.x + 1 < i_A.size())
                {
                    Point tmp;
                    tmp.x = tmpoutput.x + 1;
                    tmp.y = tmpoutput.y;
                    tmp.sum = i_A[tmpoutput.x + 1] + i_B[tmpoutput.y];
                    priorityq.push(tmp);
                }
                if (tmpoutput.y + 1 < i_B.size()) {
                    Point tmp;
                    tmp.x = tmpoutput.x;
                    tmp.y = tmpoutput.y + 1;
                    tmp.sum = i_A[tmpoutput.x] + i_B[tmpoutput.y + 1];
                    priorityq.push(tmp);
                }
            }
            else {
                if(tmpoutput.y + 1 < i_B.size()) {
                    Point tmp;
                    tmp.x = tmpoutput.x;
                    tmp.y = tmpoutput.y + 1;
                    tmp.sum = i_A[tmpoutput.x] + i_B[tmpoutput.y + 1];
                    priorityq.push(tmp);
                }
            }
        }
        return res;
    }
}
