class Solution {<br>public:
//postorder sequece and checkout if it can be construct BST
    bool validBST(vector<int> &postorder) {
        return validBST_recurse(postorder, 0, postorder.size() - 1, INT_MIN, INT_MAX);
    }
    bool validBST_recurse(vector<int> &postorder, int start, int end, int min, int max) {
        if(end < start) {
            return true;
        }
        if(end == start) {
            return postorder[end] > min && postorder[end] < max;
        }
        int partition = binaryPartition(postorder,start,end);
        bool left = validBST_recurse(postorder, start, partition, min, postorder[end]);
        bool right = validBST_recurse(postorder, partition+1, end-1, postorder[end], max);
        return left&&right;
    }
    //partition to two part, postorder[p] < postorder[end] && portorder[p+1] > postorder[end]
    int binaryPartition(vector<int> &postorder, int start, int end) {
        int target = postorder[end];
        int mid;
        end = end - 1;
        if(start == end)
            return start;
        while(start < end) {
            mid = (start + end)/2;
            if(postorder[mid] < target && (mid == end || postorder[mid+1] > target)) {
                return mid;
            }
            else if(postorder[mid] > target && (mid == start || postorder[mid-1] < target)) {
                return mid-1;
            }
            else if(postorder[mid] < target) {
                start = mid + 1;
            }
            else {
                end = mid - 1;
            }
        }
        return -1;
    }
}